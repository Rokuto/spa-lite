(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[2],{

/***/ "./node_modules/@littleq/element-lite/dist/element-lite.umd.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@littleq/element-lite/dist/element-lite.umd.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function (global, factory) {\n   true ? factory(exports) : undefined;\n})(undefined, function (exports) {\n  'use strict';\n\n  // @ts-check\n\n  // Copied from https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/utils/mixin.js\n\n  // unique global id for deduping mixins.\n  /** @type {number} */\n\n  let dedupeId = 0;\n\n  /**\n   * @type {Function}\n   * @param {!MixinFunction} [mixin]\n   * @return {Function}\n   */\n  const dedupingMixin = mixin => {\n    let mixinApplications = mixin.__mixinApplications;\n    if (!mixinApplications) {\n      mixinApplications = new WeakMap();\n      mixin.__mixinApplications = mixinApplications;\n    }\n    // maintain a unique id for each mixin\n    let mixinDedupeId = dedupeId++;\n\n    /**\n    * @type {Function}\n    * @param {!MixinFunction} base\n    * @return {MixinFunction}\n    */\n    function dedupingMixin(base) {\n      /** @type {(Object | undefined)} */\n      let baseSet = base.__mixinSet;\n      if (baseSet && baseSet[mixinDedupeId]) {\n        return base;\n      }\n\n      let map = mixinApplications;\n\n      /** @type {MixinFunction} */\n      let extended = map.get(base);\n      if (!extended) {\n        // @ts-ignore\n        extended = mixin(base);\n        map.set(base, extended);\n      }\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n\n      /** @type {(Object | undefined)} */\n      let mixinSet = Object.create(extended.__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n\n      /** @type {!MixinFunction} */\n      extended.__mixinSet = mixinSet;\n      return extended;\n    }\n\n    return dedupingMixin;\n  };\n\n  // @ts-check\n\n  // Copied from https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/utils/path.js\n\n  /**\n   * @param {string[]} path\n   * @return {string} normalized path\n   */\n  const normalizeArray = path => {\n    /** @type {string[]} */\n    let parts = [];\n    for (let i = 0; i < path.length; i++) {\n      /** @type {string[]} */\n      let args = path[i].toString().split('.');\n      for (let j = 0; j < args.length; j++) {\n        parts.push(args[j]);\n      }\n    }\n\n    return parts.join('.');\n  };\n\n  /**\n   * @param {string} path\n   * @return {boolean} if it is a path\n   */\n  const isPath = path => path.indexOf('.') >= 0;\n\n  /**\n   * @param {string} path\n   * @return {string} path's root\n   */\n  const root = path => path.indexOf('.') === -1 ? path : path.slice(0, path.indexOf('.'));\n\n  /**\n   * @param {string | string[]} path\n   * @return {string} normalize path\n   */\n  const normalize = path => Array.isArray(path) ? normalizeArray(path) : path;\n\n  /**\n   * @param {string | string[]} path\n   * @return {string[]} split path into array\n   */\n  const split = path => Array.isArray(path) ? normalize(path).split('.') : path.toString().split('.');\n\n  /**\n   * @param {object} obj\n   * @param {string|array} path\n   * @param {?object} info\n   * @return {any} the data given a path\n   */\n  const getProp = (obj, path, info) => {\n    let prop = obj;\n    let parts = split(path);\n    // Loop over path parts[0..n-1] and dereference\n    for (let i = 0; i < parts.length; i++) {\n      if (!prop) return;\n      let part = parts[i];\n      prop = prop[part];\n    }\n    if (info) info.path = parts.join('.');\n    return prop;\n  };\n\n  /**\n   * @param {object} obj\n   * @param {string} path\n   * @param {any} value\n   * @return {string} path\n   */\n  const setProp = (obj, path, value) => {\n    let prop = obj;\n    let parts = split(path);\n    let last = parts[parts.length - 1];\n    if (parts.length > 1) {\n      // Loop over path parts[0..n-2] and dereference\n      for (let i = 0; i < parts.length - 1; i++) {\n        let part = parts[i];\n        prop = prop[part];\n        if (!prop) return;\n      }\n      // Set value to object at end of path\n      prop[last] = value;\n    } else {\n      // Simple property set\n      prop[path] = value;\n    }\n    return parts.join('.');\n  };\n\n  // Copied from https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-accessors.js#L11\n\n  // Save map of native properties; this forms a blacklist or properties\n  // that won't have their values \"saved\" by `saveAccessorValue`, since\n  // reading from an HTMLElement accessor from the context of a prototype throws\n  const nativeProperties = {};\n  let proto = window.HTMLElement.prototype;\n\n  while (proto) {\n    let props = Object.getOwnPropertyNames(proto);\n    for (let i = 0; i < props.length; i++) {\n      nativeProperties[props[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  /**\n    * Copied from Polymer/polymer/lib/mixins/property-accessors.js\n    *\n    * Used to save the value of a property that will be overridden with\n    * an accessor. If the `model` is a prototype, the values will be saved\n    * in `__dataProto`, and it's up to the user (or downstream mixin) to\n    * decide how/when to set these values back into the accessors.\n    * If `model` is already an instance (it has a `__data` property), then\n    * the value will be set as a pending property, meaning the user should\n    * call `_invalidateProperties` or `_flushProperties` to take effect\n    *\n    * @param {Object} model Prototype or instance\n    * @param {string} property Name of property\n    * @return {void}\n    */\n  function saveAccessorValue(model, property) {\n    // Don't read/store value for any native properties since they could throw\n    if (!nativeProperties[property]) {\n      let value = model[property];\n      if (value !== undefined) {\n        if (model.__data) {\n          // Adding accessor to instance; update the property\n          // It is the user's responsibility to call _flushProperties\n          model._setPendingProperty(property, value);\n        } else {\n          // Adding accessor to proto; save proto's value for instance-time use\n          if (!model.__dataProto) {\n            model.__dataProto = {};\n          } else if (!model.hasOwnProperty('__dataProto')) {\n            model.__dataProto = Object.create(model.__dataProto);\n          }\n          model.__dataProto[property] = value;\n        }\n      }\n    }\n  }\n\n  // Copied from https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/utils/case-map.js\n\n  const caseMap = {};\n  // const DASH_TO_CAMEL = /-[a-z]/g;\n  const CAMEL_TO_DASH = /([A-Z])/g;\n\n  // export function dashToCamelCase (dash) {\n  //   return caseMap[dash] || (\n  //     caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,\n  //       (m) => m[1].toUpperCase()\n  //     )\n  //   );\n  // }\n\n  function camelToDashCase(camel) {\n    return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n  }\n\n  /// <reference path=\"typings-project/global.d.ts\"/>\n\n  /**\n   * Parts are copied from different mixin parts of https://github.com/Polymer/polymer/tree/__auto_generated_3.0_preview\n   *\n   * Here are the list of parts that are copied or modified\n   * - Copied:\n   *   - Private Functions\n   *     - normalizeProperties - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-mixin.js#L14\n   *     - ownProperties - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-mixin.js#L58\n   *   - Class Methods\n   *     - Static methods\n   *       - createProperties - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L25\n   *     - Protected Methods\n   *       - _initializeProtoProperties - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-accessors.js#L133\n   *       - _initializeInstanceProperties - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1177\n   *       - _setProperty - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L202\n   *       - _getProperty - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L214\n   *       - _setPendingProperty - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1419\n   *       - _flushProperties\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L300\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1502\n   *       - _shouldPropertiesChange - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L323\n   *       - _shouldPropertyChange - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L360\n   *       - _attributeToProperty - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L400\n   *       - _propertyToAttribute - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L419\n   *       - _valueToNodeAttribute - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L440\n   *       - _serializeValue\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L460\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-accessors.js#L162\n   *       - _deserializeValue\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L481\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-accessors.js#L196\n   *       - _setPendingPropertyOrPath - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1319\n   *     - HTMLElement Methods\n   *       - attributeChangedCallback - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L379\n   *       - observedAttributes - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-mixin.js#L85\n   *     - Public methods\n   *       - ready - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L149\n   *       - set - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1805\n   *\n   *\n   *\n   * - Modified\n   *   - Class Methods\n   *     - Protected Methods\n   *       - _createPropertyAccessor - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L73\n   *       - _addPropertyToAttributeMap - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L91\n   *       - _definePropertyAccessor - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L107\n   *       - _initializeProperties\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L163\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-mixin.js#L160\n   *         - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-accessors.js#L112\n   *       - _invalidateProperties - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L257\n   *     - Public Methods\n   *       - push - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1831\n   *       - pop - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1855\n   *       - splice - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1883\n   *       - shift - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1935\n   *       - unshift - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1960\n   *       - get - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/property-effects.js#L1780\n   *   - Class Constructor - https://github.com/Polymer/polymer/blob/__auto_generated_3.0_preview/lib/mixins/properties-changed.js#L122\n   *\n   * - Created\n   *   - Class Methods\n   *     - Protected Methods\n   *       - _initializeObservers\n   *       - _propertiesChanged\n   *\n   */\n\n  const ElementLiteBase = dedupingMixin(base => {\n    /**\n     * Creates a copy of `props` with each property normalized such that\n     * upgraded it is an object with at least a type property { type: Type}.\n     *\n     * @param {Object} props Properties to normalize\n     * @return {Object} Copy of input `props` with normalized properties that\n     * are in the form {type: Type}\n     * @private\n     */\n    function normalizeProperties(props) {\n      const output = {};\n      for (let p in props) {\n        const o = props[p];\n        output[p] = typeof o === 'function' ? { type: o } : o;\n      }\n      return output;\n    }\n\n    /**\n    * Returns a memoized version of the `properties` object for the\n    * given class. Properties not in object format are converted to at\n    * least {type}.\n    *\n    * @param {(ElementLiteBase | Function | typeof ElementLiteBase)} constructor ElementLiteBase constructor\n    * @return {Object} Memoized properties object\n    */\n    function ownProperties(constructor) {\n      if (!constructor.hasOwnProperty('__ownProperties')) {\n        // @ts-ignore\n        constructor.__ownProperties = constructor.hasOwnProperty('properties') && constructor.properties ?\n        // @ts-ignore\n        normalizeProperties(constructor.properties) : null;\n      }\n      // @ts-ignore\n      return constructor.__ownProperties;\n    }\n\n    /**\n     * ElementLite is a set of methods coming from Polymer Property Mixins and Property Accessor Mixins\n     * that automates the creation of setter and getters given a list of properties and\n     * allows auto-calling of methods given observers. This is the base without the lit-html counterpart\n     * @extends {HTMLElement}\n    */\n    class ElementLiteBase extends /** @type {HTMLElement} */base {\n      /**\n        * Returns a memoized version of all properties, including those inherited\n        * from super classes. Properties not in object format are converted to\n        * at least {type}.\n        *\n        * @return {Object} Object containing properties for this class\n        * @protected\n        */\n      static get _properties() {\n        if (!this.hasOwnProperty('__properties')) {\n          this.__properties = Object.assign({}, ownProperties(this));\n        }\n        return this.__properties;\n      }\n\n      /**\n       * Creates property accessors for the given property names.\n       *\n       * @param {!Object} props Object whose keys are names of accessors.\n       * @return {void}\n       * @protected\n       */\n      static createProperties(props) {\n        const proto = this.prototype;\n\n        for (let prop in props) {\n          const { readOnly, reflectToAttribute, notify, observer } = props[prop];\n          // don't stomp an existing accessor\n          if (!(prop in proto)) {\n            proto._createPropertyAccessor(prop, readOnly, reflectToAttribute, notify, observer);\n          }\n        }\n      }\n\n      /**\n        * Implements standard custom elements getter to observes the attributes\n        * listed in `properties`.\n        * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n        */\n      static get observedAttributes() {\n        const props = this._properties;\n        return props ? Object.keys(props).map(p => camelToDashCase(p)) : [];\n      }\n\n      /**\n        * Overrides `PropertiesChanged` method to return type specified in the\n        * static `properties` object for the given property.\n        * @param {string} name Name of property\n        * @return {*} Type to which to deserialize attribute\n        *\n        * @protected\n        */\n      static typeForProperty(name) {\n        const info = this._properties[name];\n        return info && info.type;\n      }\n\n      constructor() {\n        super();\n        this.__dataEnabled = false;\n        this.__dataReady = false;\n        this.__dataInvalid = false;\n        this.__data = Object.assign({}, this.__data);\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this.__dataInstanceProps = null;\n        this.__serializing = false;\n        this.__dataHasPaths = false;\n        this.__dataTemp = {};\n        /** @type {number} */\n        // NOTE: used to track re-entrant calls to `_flushProperties`\n        // path changes dirty check against `__dataTemp` only during one \"turn\"\n        // and are cleared when `__dataCounter` returns to 0.\n        this.__dataCounter = 0;\n        this._initializeProperties();\n        this._initializeObservers();\n      }\n\n      /**\n        * Called when the element is added to a document.\n        * Calls `_enableProperties` to turn on property system from\n        * `PropertiesChanged`.\n        * @suppress {missingProperties} Super may or may not implement the callback\n        * @return {void}\n        */\n      connectedCallback() {\n        if (super.connectedCallback) {\n          super.connectedCallback();\n        }\n        this._enableProperties();\n      }\n\n      /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       *\n       * @return {void}\n       * @protected\n       */\n      _enableProperties() {\n        if (!this.__dataEnabled) {\n          this.__dataEnabled = true;\n          // put here setting of attributes\n          if (this.__dataInstanceProps) {\n            this._initializeInstanceProperties(this.__dataInstanceProps);\n            this.__dataInstanceProps = null;\n          }\n          this.ready();\n        }\n      }\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.\n       *\n       * In addition, this method also sets flags for reflectToAttribute and notify.\n       * It also adds references to function calls given by observer\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @param {boolean=} reflectToAttribute When true, sets flag to `__dataReflectToAttribute`;\n       *   this will automatically set the attribute to the element tag using `setAttribute`\n       * @param {boolean=} notify When true, sets flag to `__dataNotify`;\n       *   this will automatically dispatch a `CustomEvent` given the attribute-name of the\n       *   property + `-changed` (eg. `property-name-changed` )\n       * @param {string} observer Puts the string name reference of the method in this element in\n       *   the `__dataObserver` object; The method referenced will be called when there are changes\n       *   in the property associated to it\n       * @return {void}\n       * @protected\n       */\n      _createPropertyAccessor(property, readOnly, reflectToAttribute, notify, observer) {\n        this._addPropertyToAttributeMap(property);\n\n        if (!this.hasOwnProperty('__dataHasAccessor')) {\n          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n        }\n\n        if (!this.hasOwnProperty('__readOnly')) {\n          this.__readOnly = Object.assign({}, this.__readOnly);\n        }\n\n        if (!this.hasOwnProperty('__dataReflectToAttribute')) {\n          this.__dataReflectToAttribute = Object.assign({}, this.__dataReflectToAttribute);\n        }\n\n        if (!this.hasOwnProperty('__dataNotify')) {\n          this.__dataNotify = Object.assign({}, this.__dataNotify);\n        }\n\n        if (!this.hasOwnProperty('__dataObserver')) {\n          this.__dataObserver = Object.assign({}, this.__dataObserver);\n        }\n\n        if (!this.__dataHasAccessor[property]) {\n          this.__dataHasAccessor[property] = true;\n          this._definePropertyAccessor(property, readOnly);\n        }\n\n        if (readOnly) {\n          this.__readOnly[property] = true;\n        }\n\n        if (reflectToAttribute) {\n          this.__dataReflectToAttribute[property] = true;\n        }\n\n        if (notify) {\n          this.__dataNotify[property] = true;\n        }\n\n        if (observer && typeof observer === 'string') {\n          this.__dataObserver[property] = observer;\n        }\n      }\n\n      /**\n       * Adds the given `property` to a map matching attribute names\n       * to property names, using `camelToDashCase`. This map is\n       * used when deserializing attribute values to properties.\n       *\n       * @param {string} property Name of the property\n       */\n      _addPropertyToAttributeMap(property) {\n        const attr = camelToDashCase(property);\n\n        if (!this.hasOwnProperty('__dataAttributes')) {\n          this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n        }\n\n        if (!this.hasOwnProperty('__dataAttributeProperties')) {\n          this.__dataAttributeProperties = Object.assign({}, this.__dataAttributeProperties);\n        }\n\n        if (!this.__dataAttributes[attr]) {\n          this.__dataAttributes[attr] = property;\n        }\n\n        if (!this.__dataAttributeProperties[property]) {\n          this.__dataAttributeProperties[property] = attr;\n        }\n      }\n\n      /**\n       * Defines a property accessor for the given property.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       * @return {void}\n       */\n      _definePropertyAccessor(property, readOnly) {\n        saveAccessorValue(this, property);\n        Object.defineProperty(this, property, {\n          // @ts-ignore\n          get() {\n            return this._getProperty(property);\n          },\n          set: readOnly ? function () {\n            console.error(`Cannot set on a read-only property: ${property}`);\n          } : function (value) {\n            this._setProperty(property, value);\n          }\n        });\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * @return {void}\n       * @protected\n       * @suppress {invalidCasts}\n       */\n      _initializeProperties() {\n        const props = ownProperties(this.constructor);\n        const keys = props ? Object.keys(props) : [];\n        if (!this.hasOwnProperty('__finalized')) {\n          this.__finalized = true;\n          if (props) {\n            this.constructor.createProperties(props);\n          }\n        }\n        // Capture instance properties; these will be set into accessors\n        // during first flush. Don't set them here, since we want\n        // these to overwrite defaults/constructor assignments\n        for (let p in this.__dataHasAccessor) {\n          if (this.hasOwnProperty(p)) {\n            this.__dataInstanceProps = this.__dataInstanceProps || {};\n            this.__dataInstanceProps[p] = this[p];\n            delete this[p];\n          }\n        }\n\n        // set default value\n        for (let p = 0, l = keys.length; p < l; p++) {\n          const prop = keys[p];\n          if (props[prop].value) {\n            this.__data[prop] = props[prop].value;\n          }\n        }\n\n        if (this.__dataProto) {\n          this._initializeProtoProperties(this.__dataProto);\n          this.__dataProto = null;\n        }\n      }\n\n      /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       */\n      _initializeInstanceProperties(props) {\n        let readOnly = this.__readOnly;\n        for (let prop in props) {\n          if (!readOnly || !readOnly[prop]) {\n            this.__dataPending = this.__dataPending || {};\n            this.__dataOld = this.__dataOld || {};\n            this.__data[prop] = this.__dataPending[prop] = props[prop];\n          }\n        }\n      }\n\n      /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       */\n      _initializeProtoProperties(props) {\n        for (let p in props) {\n          this._setProperty(p, props[p]);\n        }\n      }\n\n      /**\n       * Initializes the observers to call methods when property values have changed\n       *\n       * @return {void}\n       * @protected\n       * @suppress {invalidCasts}\n       */\n\n      _initializeObservers() {\n        const observers = this.constructor.observers;\n\n        if (!this.hasOwnProperty('__dataMethodObserver')) {\n          this.__dataMethodObserver = Object.assign({}, this.__dataMethodObserver);\n        }\n\n        if (observers && observers.length) {\n          for (let i = 0, l = observers.length; i < l; i++) {\n            const fnArgs = observers[i].split('(');\n            const fn = fnArgs[0].trim();\n            const args = fnArgs[1].trim().replace(/\\)$/g, '').split(',').map(arg => arg.trim());\n\n            for (let p = 0, m = args.length; p < m; p++) {\n              const rootPath = root(args[p]);\n\n              if (!this.__dataMethodObserver[args[p]]) {\n                this.__dataMethodObserver[args[p]] = { methods: [], root: root(args[p]) };\n              }\n\n              if (this.__dataMethodObserver[args[p]].methods.findIndex(item => item.fn === fn) < 0) {\n                this.__dataMethodObserver[args[p]].methods.push({ fn, args });\n              }\n\n              if (!this.__dataMethodObserver[rootPath]) {\n                this.__dataMethodObserver[rootPath] = { methods: [], root: root(rootPath) };\n              }\n\n              if (this.__dataMethodObserver[rootPath].methods.findIndex(item => item.fn === fn) < 0) {\n                this.__dataMethodObserver[rootPath].methods.push({ fn, args });\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       * @protected\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Returns the value for the given property.\n       *\n       * @param {string} property Name of property\n       * @return {*} Value for the given property\n       * @protected\n       */\n      _getProperty(property) {\n        return this.__data[property];\n      }\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify Set to true if this change should\n       *  cause a property notification event dispatch\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n      _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n        if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {\n          // Dirty check changes being set to a path against the actual object,\n          // since this is the entry point for paths into the system; from here\n          // the only dirty checks are against the `__dataTemp` cache to prevent\n          // duplicate work in the same turn only. Note, if this was a notification\n          // of a change already set to a path (isPathNotification: true),\n          // we always let the change through and skip the `set` since it was\n          // already dirty checked at the point of entry and the underlying\n          // object has already been updated\n          if (!isPathNotification) {\n            let old = getProp(this, path, null);\n            path = setProp(this, path, value);\n            // Use property-accessor's simpler dirty check\n            if (!path || !this._shouldPropertyChange(path, value, old)) return false;\n          }\n          this.__dataHasPaths = true;\n          return this._setPendingProperty(path, value, shouldNotify);\n        } else {\n          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) return this._setPendingProperty(path, value, shouldNotify);else this[path] = value;\n        }\n        return false;\n      }\n\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify\n       * @return {boolean} Returns true if the property changed\n       * @protected\n       */\n      _setPendingProperty(property, value, shouldNotify) {\n        let path = this.__dataHasPaths && isPath(property);\n        let prevProps = path ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n\n          if (path) {\n            this.__dataTemp[property] = value;\n          } else {\n            this.__data[property] = value;\n          }\n\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @return {void}\n       * @protected\n       */\n      _invalidateProperties() {\n        if (!this.__dataInvalid && this.__dataReady) {\n          this.__dataInvalid = true;\n\n          Promise.resolve().then(() => {\n            if (this.__dataInvalid) {\n              this.__dataInvalid = false;\n              this._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       * @return {void}\n       * @protected\n       */\n      _flushProperties() {\n        this.__dataCounter++;\n\n        const props = this.__data;\n        const changedProps = this.__dataPending;\n        const old = this.__dataOld;\n        if (this._shouldPropertiesChange(props, changedProps, old)) {\n          this.__dataPending = null;\n          this.__dataOld = {};\n          this._propertiesChanged(props, changedProps, old);\n        }\n\n        this.__dataCounter--;\n      }\n\n      /**\n       * Called in `_flushProperties` to determine if `_propertiesChanged`\n       * should be called. The default implementation returns true if\n       * properties are pending. Override to customize when\n       * `_propertiesChanged` is called.\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {!Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {!Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {boolean} true if changedProps is truthy\n       */\n      _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n        return Boolean(changedProps);\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {!Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {!Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       * @protected\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {\n        // eslint-disable-line no-unused-vars\n        const fns = {};\n        let keys = Object.keys(changedProps);\n        this.__dataHasPaths = false;\n\n        for (let i = 0, l = keys.length; i < l; i++) {\n          const key = keys[i];\n          const prop = root(key);\n\n          if (this.__dataReflectToAttribute[prop]) {\n            this._propertyToAttribute(prop, this.__dataAttributeProperties[prop], this.__data[prop]);\n          }\n\n          if (this.__dataNotify[root(prop)]) {\n            this.dispatchEvent(new window.CustomEvent(`${camelToDashCase(root(prop))}-changed`, { detail: this.__data[root(prop)] }));\n          }\n\n          if (this.__dataObserver[prop]) {\n            const fn = this[this.__dataObserver[prop]];\n            const args = [this.__data[prop], oldProps && oldProps[prop]];\n\n            if (fn) {\n              fns[this.__dataObserver[prop]] = { fn: fn.bind(this), args };\n            } else {\n              console.warn(`There's not observer named ${this.__dataObserver[prop]} for ${prop}`);\n            }\n          }\n\n          if (this.__dataMethodObserver[key]) {\n            const { methods } = this.__dataMethodObserver[key];\n            for (let p = 0, m = methods.length; p < m; p++) {\n              const { fn: fnName, args: argNames } = methods[p];\n              const fn = this[fnName];\n              const args = [];\n              for (let a = 0, n = argNames.length; a < n; a++) {\n                args.push(this.get(argNames[a]));\n              }\n\n              if (fn) {\n                fns[fnName] = { fn: fn.bind(this), args };\n              } else {\n                console.warn(`There's not method named ${fnName}`);\n              }\n            }\n          }\n        }\n\n        keys = Object.keys(fns);\n        for (let i = 0, l = keys.length; i < l; i++) {\n          const { fn, args } = fns[keys[i]];\n          fn(...args);\n        }\n\n        // Clear temporary cache at end of turn\n        if (this.__dataCounter === 1) {\n          this.__dataTemp = {};\n        }\n      }\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` if a strict equality\n       * check fails. The method always returns false for `NaN`.\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check\n          old !== value && (\n          // This ensures (old==NaN, value==NaN) always returns false\n          old === old || value === value)\n        );\n      }\n\n      /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       * @return {void}\n       * @suppress {missingProperties} Super may or may not implement the callback\n       */\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          this._attributeToProperty(name, value);\n        }\n\n        if (super.attributeChangedCallback) {\n          super.attributeChangedCallback(name, old, value);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {?string} value of the attribute.\n       * returned from `typeForProperty`\n       * @return {void}\n       */\n      _attributeToProperty(attribute, value) {\n        if (!this.__serializing) {\n          const map = this.__dataAttributes;\n          const property = map && map[attribute] || attribute;\n          this[property] = this._deserializeValue(value, this.constructor.typeForProperty(property));\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect to.\n       * @param {any=} value Property value to refect.\n       * @return {void}\n       */\n      _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = arguments.length < 3 ? this[property] : value;\n        this._valueToNodeAttribute(this, value, attribute || camelToDashCase(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element | ElementLiteBase} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       * @return {void}\n       */\n      _valueToNodeAttribute(node, value, attribute) {\n        const str = this._serializeValue(value);\n\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called when setting JS property values to\n       * HTML attributes.  Users may override this method to provide\n       * serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided\n       * property  value.\n       */\n      _serializeValue(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value) {\n          case 'boolean':\n            return value ? '' : undefined;\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              try {\n                return JSON.stringify(value);\n              } catch (x) {\n                return '';\n              }\n            }\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called when reading HTML attribute values to\n       * JS properties.  Users may override this method to provide\n       * deserialization for custom `type`s. Types for `Boolean`, `String`,\n       * and `Number` convert attributes to the expected types.\n       *\n       * @param {?string} value Value to deserialize.\n       * @param {any=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n      _deserializeValue(value, type) {\n        /** @type {any} */\n        let outValue;\n        switch (type) {\n          case Object:\n            try {\n              outValue = JSON.parse(value);\n            } catch (x) {\n              // allow non-JSON literals like Strings and Numbers\n              outValue = value;\n            }\n            break;\n          case Array:\n            try {\n              outValue = JSON.parse(value);\n            } catch (x) {\n              outValue = null;\n              console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n            }\n            break;\n          case Date:\n            // @ts-ignore\n            outValue = isNaN(value) ? String(value) : Number(value);\n            outValue = new Date(outValue);\n            break;\n          case Boolean:\n            return value !== null;\n          case Number:\n            return Number(value);\n          default:\n            return value;\n        }\n        return outValue;\n      }\n\n      /**\n       * Lifecycle callback called when properties are enabled via\n       * `_enableProperties`.\n       *\n       * Users may override this function to implement behavior that is\n       * dependent on the element having its property data initialized, e.g.\n       * from defaults (initialized from `constructor`, `_initializeProperties`),\n       * `attributeChangedCallback`, or values propagated from host e.g. via\n       * bindings.  `super.ready()` must be called to ensure the data system\n       * becomes enabled.\n       *\n       * @return {void}\n       * @public\n       */\n      ready() {\n        this.__dataReady = true;\n        this._flushProperties();\n      }\n\n      /**\n         * Convenience method for setting a value to a path and notifying any\n         * elements bound to the same path.\n         *\n         * Note, if any part in the path except for the last is undefined,\n         * this method does nothing (this method does not throw when\n         * dereferencing undefined paths).\n         *\n         * @param {string} path Path to the value\n         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n         *   bracketed expressions are not supported; string-based path parts\n         *   *must* be separated by dots.  Note that when dereferencing array\n         *   indices, the index may be used as a dotted part directly\n         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n         * @param {*} value Value to set at the specified path.\n         * @return {void}\n         * @public\n        */\n      set(path, value) {\n        if (path && (!this.__readOnly || !this.__readOnly[root(path)]) && this._setPendingPropertyOrPath(path, value, true)) this._invalidateProperties();\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n      push(path, ...items) {\n        let info = { path: '' };\n        let array = getProp(this, path, info);\n        // use immutability for now\n        let ret = [...array, ...items];\n        if (items.length) this.set(path, ret);\n        return ret.length;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      pop(path) {\n        let info = { path: '' };\n        let array = getProp(this, path, info);\n        let hadLength = Boolean(array.length);\n        // use immutability for now\n        if (hadLength) {\n          let ret = array.slice(0, -1);\n          this.set(path, ret);\n          return array.slice(-1);\n        }\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of remaining items.\n       * @public\n       */\n      splice(path, start, deleteCount, ...items) {\n        let info = { path: '' };\n        let array = getProp(this, path, info);\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) start = array.length - Math.floor(-start);else if (start) start = Math.floor(start);\n        // array.splice does different things based on the number of arguments\n        // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n        // do different things. In the former, the whole array is cleared. In the\n        // latter, no items are removed.\n        // This means that we need to detect whether 1. one of the arguments\n        // is actually passed in and then 2. determine how many arguments\n        // we should pass on to the native array.splice\n        //\n        let ret;\n        // Omit any additional arguments if they were not passed in\n        ret = [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];\n        // ret = arguments.length === 2 ? array.splice(start) : array.splice(start, deleteCount, ...items);\n\n        // Either start was undefined and the others were defined, but in this\n        // case we can safely pass on all arguments\n        //\n        // Note: this includes the case where none of the arguments were passed in,\n        // e.g. this.splice('array'). However, if both start and deleteCount\n        // are undefined, array.splice will not modify the array (as expected)\n\n        // At the end, check whether any items were passed in (e.g. insertions)\n        // or if the return array contains items (e.g. deletions).\n        // Only notify if items were added or deleted.\n        if (items.length || ret.length) {\n          this.set(path, ret);\n          // notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      shift(path) {\n        let info = { path: '' };\n        let array = getProp(this, path, info);\n        let hadLength = Boolean(array.length);\n        // use immutability for now\n        if (hadLength) {\n          let ret = array.slice(1);\n          this.set(path, ret);\n          return array.slice(0, 1);\n        }\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n      unshift(path, ...items) {\n        let info = { path: '' };\n        let array = getProp(this, path, info);\n        // use immutability for now\n        let ret = [...items, ...array];\n        if (items.length) this.set(path, ret);\n        return ret.length;\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n      get(path, root$$1) {\n        return getProp(root$$1 || this, path, null);\n      }\n    }\n\n    return ElementLiteBase;\n  });\n\n  const ElementLiteStaticShadow = dedupingMixin(base => {\n    /**\n     * ElementLite is a set of methods coming from Polymer Property Mixins and Property Accessor Mixins\n     * that automates the creation of setter and getters given a list of properties and\n     * allows auto-calling of methods given observers. This uses a static shadow DOM. It doesn't use\n     * lit-html\n     * @extends {ElementLiteBase}\n    */\n    class ElementLiteStaticShadow extends ElementLiteBase(base) {\n      ready() {\n        // attaches shadow\n        this.attachShadow({ mode: 'open' });\n        super.ready();\n\n        // renders the shadowRoot statically\n        this.shadowRoot = this.render();\n      }\n\n      /**\n       * Return the html string of the shadowRoot\n       */\n      render() {\n        return ``;\n      }\n    }\n\n    return ElementLiteStaticShadow;\n  });\n\n  /**\n   * @license\n   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   * This code may only be used under the BSD style license found at\n   * http://polymer.github.io/LICENSE.txt\n   * The complete set of authors may be found at\n   * http://polymer.github.io/AUTHORS.txt\n   * The complete set of contributors may be found at\n   * http://polymer.github.io/CONTRIBUTORS.txt\n   * Code distributed by Google as part of the polymer project is also\n   * subject to an additional IP rights grant found at\n   * http://polymer.github.io/PATENTS.txt\n   */\n  // The first argument to JS template tags retain identity across multiple\n  // calls to a tag for the same literal, so we can cache work done per literal\n  // in a Map.\n  const templateCaches = new Map();\n  /**\n   * The return type of `html`, which holds a Template and the values from\n   * interpolated expressions.\n   */\n  class TemplateResult {\n    constructor(strings, values, type, partCallback = defaultPartCallback) {\n      this.strings = strings;\n      this.values = values;\n      this.type = type;\n      this.partCallback = partCallback;\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    getHTML() {\n      const l = this.strings.length - 1;\n      let html = '';\n      let isTextBinding = true;\n      for (let i = 0; i < l; i++) {\n        const s = this.strings[i];\n        html += s;\n        // We're in a text position if the previous string closed its tags.\n        // If it doesn't have any tags, then we use the previous text position\n        // state.\n        const closing = findTagClose(s);\n        isTextBinding = closing > -1 ? closing < s.length : isTextBinding;\n        html += isTextBinding ? nodeMarker : marker;\n      }\n      html += this.strings[l];\n      return html;\n    }\n    getTemplateElement() {\n      const template = document.createElement('template');\n      template.innerHTML = this.getHTML();\n      return template;\n    }\n  }\n  /**\n   * The default TemplateFactory which caches Templates keyed on\n   * result.type and result.strings.\n   */\n  function defaultTemplateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n      templateCache = new Map();\n      templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      template = new Template(result, result.getTemplateElement());\n      templateCache.set(result.strings, template);\n    }\n    return template;\n  }\n  /**\n   * Renders a template to a container.\n   *\n   * To update a container with new values, reevaluate the template literal and\n   * call `render` with the new result.\n   *\n   * @param result a TemplateResult created by evaluating a template tag like\n   *     `html` or `svg.\n   * @param container A DOM parent to render to. The entire contents are either\n   *     replaced, or efficiently updated if the same result type was previous\n   *     rendered there.\n   * @param templateFactory a function to create a Template or retreive one from\n   *     cache.\n   */\n  function render(result, container, templateFactory = defaultTemplateFactory) {\n    const template = templateFactory(result);\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === template && instance._partCallback === result.partCallback) {\n      instance.update(result.values);\n      return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(template, result.partCallback, templateFactory);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    removeNodes(container, container.firstChild);\n    container.appendChild(fragment);\n  }\n  /**\n   * An expression marker with embedded unique key to avoid collision with\n   * possible text in templates.\n   */\n  const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n  /**\n   * An expression marker used text-posisitions, not attribute positions,\n   * in template.\n   */\n  const nodeMarker = `<!--${marker}-->`;\n  const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n  /**\n   * This regex extracts the attribute name preceding an attribute-position\n   * expression. It does this by matching the syntax allowed for attributes\n   * against the string literal directly preceding the expression, assuming that\n   * the expression is in an attribute-value position.\n   *\n   * See attributes in the HTML spec:\n   * https://www.w3.org/TR/html5/syntax.html#attributes-0\n   *\n   * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n   *\n   * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n   * https://www.w3.org/TR/html5/infrastructure.html#space-character\n   *\n   * So an attribute is:\n   *  * The name: any character except a control character, space character, ('),\n   *    (\"), \">\", \"=\", or \"/\"\n   *  * Followed by zero or more space characters\n   *  * Followed by \"=\"\n   *  * Followed by zero or more space characters\n   *  * Followed by:\n   *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n   *    * (\") then any non-(\"), or\n   *    * (') then any non-(')\n   */\n  const lastAttributeNameRegex = /[ \\x09\\x0a\\x0c\\x0d]([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)[ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*)$/;\n  /**\n   * Finds the closing index of the last closed HTML tag.\n   * This has 3 possible return values:\n   *   - `-1`, meaning there is no tag in str.\n   *   - `string.length`, meaning the last opened tag is unclosed.\n   *   - Some positive number < str.length, meaning the index of the closing '>'.\n   */\n  function findTagClose(str) {\n    const close = str.lastIndexOf('>');\n    const open = str.indexOf('<', close + 1);\n    return open > -1 ? str.length : close;\n  }\n  /**\n   * A placeholder for a dynamic expression in an HTML template.\n   *\n   * There are two built-in part types: AttributePart and NodePart. NodeParts\n   * always represent a single dynamic expression, while AttributeParts may\n   * represent as many expressions are contained in the attribute.\n   *\n   * A Template's parts are mutable, so parts can be replaced or modified\n   * (possibly to implement different template semantics). The contract is that\n   * parts can only be replaced, not removed, added or reordered, and parts must\n   * always consume the correct number of values in their `update()` method.\n   *\n   * TODO(justinfagnani): That requirement is a little fragile. A\n   * TemplateInstance could instead be more careful about which values it gives\n   * to Part.update().\n   */\n  class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n      this.type = type;\n      this.index = index;\n      this.name = name;\n      this.rawName = rawName;\n      this.strings = strings;\n    }\n  }\n  /**\n   * An updateable Template that tracks the location of dynamic parts.\n   */\n  class Template {\n    constructor(result, element) {\n      this.parts = [];\n      this.element = element;\n      const content = this.element.content;\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n      const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                                                            NodeFilter.SHOW_TEXT */, null, false);\n      let index = -1;\n      let partIndex = 0;\n      const nodesToRemove = [];\n      // The actual previous node, accounting for removals: if a node is removed\n      // it will never be the previousNode.\n      let previousNode;\n      // Used to set previousNode at the top of the loop.\n      let currentNode;\n      while (walker.nextNode()) {\n        index++;\n        previousNode = currentNode;\n        const node = currentNode = walker.currentNode;\n        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n            if (!node.hasAttributes()) {\n              continue;\n            }\n            const attributes = node.attributes;\n            // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n            // attributes are not guaranteed to be returned in document order. In\n            // particular, Edge/IE can return them out of order, so we cannot assume\n            // a correspondance between part index and attribute index.\n            let count = 0;\n            for (let i = 0; i < attributes.length; i++) {\n              if (attributes[i].value.indexOf(marker) >= 0) {\n                count++;\n              }\n            }\n            while (count-- > 0) {\n              // Get the template literal section leading up to the first\n              // expression in this attribute attribute\n              const stringForPart = result.strings[partIndex];\n              // Find the attribute name\n              const attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1];\n              // Find the corresponding attribute\n              const attribute = attributes.getNamedItem(attributeNameInPart);\n              const stringsForAttributeValue = attribute.value.split(markerRegex);\n              this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));\n              node.removeAttribute(attribute.name);\n              partIndex += stringsForAttributeValue.length - 1;\n            }\n          } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n            const nodeValue = node.nodeValue;\n            if (nodeValue.indexOf(marker) < 0) {\n              continue;\n            }\n            const parent = node.parentNode;\n            const strings = nodeValue.split(markerRegex);\n            const lastIndex = strings.length - 1;\n            // We have a part for each match found\n            partIndex += lastIndex;\n            // We keep this current node, but reset its content to the last\n            // literal part. We insert new literal nodes before this so that the\n            // tree walker keeps its position correctly.\n            node.textContent = strings[lastIndex];\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            for (let i = 0; i < lastIndex; i++) {\n              parent.insertBefore(document.createTextNode(strings[i]), node);\n              this.parts.push(new TemplatePart('node', index++));\n            }\n          } else if (node.nodeType === 8 /* Node.COMMENT_NODE */ && node.nodeValue === marker) {\n          const parent = node.parentNode;\n          // Add a new marker node to be the startNode of the Part if any of the\n          // following are true:\n          //  * We don't have a previousSibling\n          //  * previousSibling is being removed (thus it's not the\n          //    `previousNode`)\n          //  * previousSibling is not a Text node\n          //\n          // TODO(justinfagnani): We should be able to use the previousNode here\n          // as the marker node and reduce the number of extra nodes we add to a\n          // template. See https://github.com/PolymerLabs/lit-html/issues/147\n          const previousSibling = node.previousSibling;\n          if (previousSibling === null || previousSibling !== previousNode || previousSibling.nodeType !== Node.TEXT_NODE) {\n            parent.insertBefore(document.createTextNode(''), node);\n          } else {\n            index--;\n          }\n          this.parts.push(new TemplatePart('node', index++));\n          nodesToRemove.push(node);\n          // If we don't have a nextSibling add a marker node.\n          // We don't have to check if the next node is going to be removed,\n          // because that node will induce a new marker if so.\n          if (node.nextSibling === null) {\n            parent.insertBefore(document.createTextNode(''), node);\n          } else {\n            index--;\n          }\n          currentNode = previousNode;\n          partIndex++;\n        }\n      }\n      // Remove text binding nodes after the walk to not disturb the TreeWalker\n      for (const n of nodesToRemove) {\n        n.parentNode.removeChild(n);\n      }\n    }\n  }\n  /**\n   * Returns a value ready to be inserted into a Part from a user-provided value.\n   *\n   * If the user value is a directive, this invokes the directive with the given\n   * part. If the value is null, it's converted to undefined to work better\n   * with certain DOM APIs, like textContent.\n   */\n  const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (isDirective(value)) {\n      value = value(part);\n      return directiveValue;\n    }\n    return value === null ? undefined : value;\n  };\n  const isDirective = o => typeof o === 'function' && o.__litDirective === true;\n  /**\n   * A sentinel value that signals that a value was handled by a directive and\n   * should not be written to the DOM.\n   */\n  const directiveValue = {};\n  const isPrimitiveValue = value => value === null || !(typeof value === 'object' || typeof value === 'function');\n  class AttributePart {\n    constructor(instance, element, name, strings) {\n      this.instance = instance;\n      this.element = element;\n      this.name = name;\n      this.strings = strings;\n      this.size = strings.length - 1;\n      this._previousValues = [];\n    }\n    _interpolate(values, startIndex) {\n      const strings = this.strings;\n      const l = strings.length - 1;\n      let text = '';\n      for (let i = 0; i < l; i++) {\n        text += strings[i];\n        const v = getValue(this, values[startIndex + i]);\n        if (v && v !== directiveValue && (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n          for (const t of v) {\n            // TODO: we need to recursively call getValue into iterables...\n            text += t;\n          }\n        } else {\n          text += v;\n        }\n      }\n      return text + strings[l];\n    }\n    _equalToPreviousValues(values, startIndex) {\n      for (let i = startIndex; i < startIndex + this.size; i++) {\n        if (this._previousValues[i] !== values[i] || !isPrimitiveValue(values[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    setValue(values, startIndex) {\n      if (this._equalToPreviousValues(values, startIndex)) {\n        return;\n      }\n      const s = this.strings;\n      let value;\n      if (s.length === 2 && s[0] === '' && s[1] === '') {\n        // An expression that occupies the whole attribute value will leave\n        // leading and trailing empty strings.\n        value = getValue(this, values[startIndex]);\n        if (Array.isArray(value)) {\n          value = value.join('');\n        }\n      } else {\n        value = this._interpolate(values, startIndex);\n      }\n      if (value !== directiveValue) {\n        this.element.setAttribute(this.name, value);\n      }\n      this._previousValues = values;\n    }\n  }\n  class NodePart {\n    constructor(instance, startNode, endNode) {\n      this.instance = instance;\n      this.startNode = startNode;\n      this.endNode = endNode;\n      this._previousValue = undefined;\n    }\n    setValue(value) {\n      value = getValue(this, value);\n      if (value === directiveValue) {\n        return;\n      }\n      if (isPrimitiveValue(value)) {\n        // Handle primitive values\n        // If the value didn't change, do nothing\n        if (value === this._previousValue) {\n          return;\n        }\n        this._setText(value);\n      } else if (value instanceof TemplateResult) {\n        this._setTemplateResult(value);\n      } else if (Array.isArray(value) || value[Symbol.iterator]) {\n        this._setIterable(value);\n      } else if (value instanceof Node) {\n        this._setNode(value);\n      } else if (value.then !== undefined) {\n        this._setPromise(value);\n      } else {\n        // Fallback, will render the string representation\n        this._setText(value);\n      }\n    }\n    _insert(node) {\n      this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n      if (this._previousValue === value) {\n        return;\n      }\n      this.clear();\n      this._insert(value);\n      this._previousValue = value;\n    }\n    _setText(value) {\n      const node = this.startNode.nextSibling;\n      value = value === undefined ? '' : value;\n      if (node === this.endNode.previousSibling && node.nodeType === Node.TEXT_NODE) {\n        // If we only have a single text node between the markers, we can just\n        // set its value, rather than replacing it.\n        // TODO(justinfagnani): Can we just check if _previousValue is\n        // primitive?\n        node.textContent = value;\n      } else {\n        this._setNode(document.createTextNode(value));\n      }\n      this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n      const template = this.instance._getTemplate(value);\n      let instance;\n      if (this._previousValue && this._previousValue.template === template) {\n        instance = this._previousValue;\n      } else {\n        instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);\n        this._setNode(instance._clone());\n        this._previousValue = instance;\n      }\n      instance.update(value.values);\n    }\n    _setIterable(value) {\n      // For an Iterable, we create a new InstancePart per item, then set its\n      // value to the item. This is a little bit of overhead for every item in\n      // an Iterable, but it lets us recurse easily and efficiently update Arrays\n      // of TemplateResults that will be commonly returned from expressions like:\n      // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n      // If _previousValue is an array, then the previous render was of an\n      // iterable and _previousValue will contain the NodeParts from the previous\n      // render. If _previousValue is not an array, clear this part and make a new\n      // array for NodeParts.\n      if (!Array.isArray(this._previousValue)) {\n        this.clear();\n        this._previousValue = [];\n      }\n      // Lets us keep track of how many items we stamped so we can clear leftover\n      // items from a previous render\n      const itemParts = this._previousValue;\n      let partIndex = 0;\n      for (const item of value) {\n        // Try to reuse an existing part\n        let itemPart = itemParts[partIndex];\n        // If no existing part, create a new one\n        if (itemPart === undefined) {\n          // If we're creating the first item part, it's startNode should be the\n          // container's startNode\n          let itemStart = this.startNode;\n          // If we're not creating the first part, create a new separator marker\n          // node, and fix up the previous part's endNode to point to it\n          if (partIndex > 0) {\n            const previousPart = itemParts[partIndex - 1];\n            itemStart = previousPart.endNode = document.createTextNode('');\n            this._insert(itemStart);\n          }\n          itemPart = new NodePart(this.instance, itemStart, this.endNode);\n          itemParts.push(itemPart);\n        }\n        itemPart.setValue(item);\n        partIndex++;\n      }\n      if (partIndex === 0) {\n        this.clear();\n        this._previousValue = undefined;\n      } else if (partIndex < itemParts.length) {\n        const lastPart = itemParts[partIndex - 1];\n        // Truncate the parts array so _previousValue reflects the current state\n        itemParts.length = partIndex;\n        this.clear(lastPart.endNode.previousSibling);\n        lastPart.endNode = this.endNode;\n      }\n    }\n    _setPromise(value) {\n      this._previousValue = value;\n      value.then(v => {\n        if (this._previousValue === value) {\n          this.setValue(v);\n        }\n      });\n    }\n    clear(startNode = this.startNode) {\n      removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n  }\n  const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n      return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    } else if (templatePart.type === 'node') {\n      return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n  };\n  /**\n   * An instance of a `Template` that can be attached to the DOM and updated\n   * with new values.\n   */\n  class TemplateInstance {\n    constructor(template, partCallback, getTemplate) {\n      this._parts = [];\n      this.template = template;\n      this._partCallback = partCallback;\n      this._getTemplate = getTemplate;\n    }\n    update(values) {\n      let valueIndex = 0;\n      for (const part of this._parts) {\n        if (part.size === undefined) {\n          part.setValue(values[valueIndex]);\n          valueIndex++;\n        } else {\n          part.setValue(values, valueIndex);\n          valueIndex += part.size;\n        }\n      }\n    }\n    _clone() {\n      const fragment = document.importNode(this.template.element.content, true);\n      const parts = this.template.parts;\n      if (parts.length > 0) {\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n        // null\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                                                               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        for (let i = 0; i < parts.length; i++) {\n          const part = parts[i];\n          while (index < part.index) {\n            index++;\n            walker.nextNode();\n          }\n          this._parts.push(this._partCallback(this, part, walker.currentNode));\n        }\n      }\n      return fragment;\n    }\n  }\n  /**\n   * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n   * (exclusive), from `container`.\n   */\n  const removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n      const n = node.nextSibling;\n      container.removeChild(node);\n      node = n;\n    }\n  };\n\n  /**\n   * @license\n   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   * This code may only be used under the BSD style license found at\n   * http://polymer.github.io/LICENSE.txt\n   * The complete set of authors may be found at\n   * http://polymer.github.io/AUTHORS.txt\n   * The complete set of contributors may be found at\n   * http://polymer.github.io/CONTRIBUTORS.txt\n   * Code distributed by Google as part of the polymer project is also\n   * subject to an additional IP rights grant found at\n   * http://polymer.github.io/PATENTS.txt\n   */\n  /**\n   * Interprets a template literal as a lit-extended HTML template.\n   */\n  const html$1 = (strings, ...values) => new TemplateResult(strings, values, 'html', extendedPartCallback);\n  /**\n   * A PartCallback which allows templates to set properties and declarative\n   * event handlers.\n   *\n   * Properties are set by default, instead of attributes. Attribute names in\n   * lit-html templates preserve case, so properties are case sensitive. If an\n   * expression takes up an entire attribute value, then the property is set to\n   * that value. If an expression is interpolated with a string or other\n   * expressions then the property is set to the string result of the\n   * interpolation.\n   *\n   * To set an attribute instead of a property, append a `$` suffix to the\n   * attribute name.\n   *\n   * Example:\n   *\n   *     html`<button class$=\"primary\">Buy Now</button>`\n   *\n   * To set an event handler, prefix the attribute name with `on-`:\n   *\n   * Example:\n   *\n   *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`\n   *\n   */\n  const extendedPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n      if (templatePart.rawName.startsWith('on-')) {\n        const eventName = templatePart.rawName.slice(3);\n        return new EventPart(instance, node, eventName);\n      }\n      if (templatePart.name.endsWith('$')) {\n        const name = templatePart.name.slice(0, -1);\n        return new AttributePart(instance, node, name, templatePart.strings);\n      }\n      if (templatePart.name.endsWith('?')) {\n        const name = templatePart.name.slice(0, -1);\n        return new BooleanAttributePart(instance, node, name, templatePart.strings);\n      }\n      return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);\n    }\n    return defaultPartCallback(instance, templatePart, node);\n  };\n  /**\n   * Implements a boolean attribute, roughly as defined in the HTML\n   * specification.\n   *\n   * If the value is truthy, then the attribute is present with a value of\n   * ''. If the value is falsey, the attribute is removed.\n   */\n  class BooleanAttributePart extends AttributePart {\n    setValue(values, startIndex) {\n      const s = this.strings;\n      if (s.length === 2 && s[0] === '' && s[1] === '') {\n        const value = getValue(this, values[startIndex]);\n        if (value === directiveValue) {\n          return;\n        }\n        if (value) {\n          this.element.setAttribute(this.name, '');\n        } else {\n          this.element.removeAttribute(this.name);\n        }\n      } else {\n        throw new Error('boolean attributes can only contain a single expression');\n      }\n    }\n  }\n  class PropertyPart extends AttributePart {\n    setValue(values, startIndex) {\n      const s = this.strings;\n      let value;\n      if (this._equalToPreviousValues(values, startIndex)) {\n        return;\n      }\n      if (s.length === 2 && s[0] === '' && s[1] === '') {\n        // An expression that occupies the whole attribute value will leave\n        // leading and trailing empty strings.\n        value = getValue(this, values[startIndex]);\n      } else {\n        // Interpolation, so interpolate\n        value = this._interpolate(values, startIndex);\n      }\n      if (value !== directiveValue) {\n        this.element[this.name] = value;\n      }\n      this._previousValues = values;\n    }\n  }\n  class EventPart {\n    constructor(instance, element, eventName) {\n      this.instance = instance;\n      this.element = element;\n      this.eventName = eventName;\n    }\n    setValue(value) {\n      const listener = getValue(this, value);\n      const previous = this._listener;\n      if (listener === previous) {\n        return;\n      }\n      this._listener = listener;\n      if (previous != null) {\n        this.element.removeEventListener(this.eventName, previous);\n      }\n      if (listener != null) {\n        this.element.addEventListener(this.eventName, listener);\n      }\n    }\n  }\n\n  /// <reference path=\"typings-project/global.d.ts\"/>\n  const ElementLiteLitOnly = dedupingMixin(base => {\n    /**\n     * ElementLite is a set of methods coming from Polymer Property Mixins and Property Accessor Mixins\n     * that automates the creation of setter and getters given a list of properties and\n     * allows auto-calling of methods given observers. This doesn't use the base ElementLite, but uses lit-html\n     * only.\n     *\n     * @extends {HTMLElement}\n    */\n    class ElementLiteLitOnly extends /** @type {HTMLElement} */base {\n      connectedCallback() {\n        if (super.connectedCallback) super.connectedCallback();\n        this.attachShadow({ mode: 'open' });\n\n        // renders the shadowRoot statically\n        const result = this.render(this);\n\n        if (result && this.shadowRoot) {\n          render(this.render(this) || html$1``, /** @type {DocumentFragment} */this.shadowRoot);\n        }\n      }\n\n      /**\n       * Return a template result to render using lit-html.\n       */\n      render(self) {\n        return html$1``;\n      }\n    }\n\n    return ElementLiteLitOnly;\n  });\n\n  const ElementLite = dedupingMixin(base => {\n    /**\n     * ElementLite is a set of methods coming from Polymer Property Mixins and Property Accessor Mixins\n     * that automates the creation of setter and getters given a list of properties and\n     * allows auto-calling of methods given observers.\n     * @extends {ElementLiteBase}\n    */\n    class ElementLite extends ElementLiteBase( /** @type {HTMLElement} */base) {\n      static get noShadow() {\n        return false;\n      }\n\n      ready() {\n        if (!this.constructor.noShadow) this.attachShadow({ mode: 'open' });\n        super.ready();\n        this._setShadow();\n      }\n\n      _setShadow() {\n        const result = this.render(this);\n        if (result) {\n          render(this.render(this) || html$1``, this.shadowRoot || this);\n        }\n      }\n\n      /*\n       * This is called when the attributes/properties has been changed.\n       * This function in particular re-renders parts of the shadowRoot\n       * based on lit-html's render function.\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {\n        this.__isChanging = true;\n        super._propertiesChanged(currentProps, changedProps, oldProps);\n        this._setShadow();\n\n        if (this.__resolveRenderComplete) {\n          window.requestAnimationFrame(() => {\n            this.__resolveRenderComplete();\n          });\n        }\n\n        this.__isChanging = false;\n      }\n\n      get afterRender() {\n        if (!this.__renderComplete) {\n          this.__renderComplete = new Promise(resolve => {\n            this.__resolveRenderComplete = () => {\n              this.__resolveRenderComplete = this.__renderComplete = null;\n              resolve();\n            };\n          });\n          if (!this.__isInvalid && this.__resolveRenderComplete) {\n            this.__resolveRenderComplete();\n          }\n        }\n        return this.__renderComplete;\n      }\n\n      /**\n       * Override which provides tracking of invalidated state.\n      */\n      _invalidateProperties() {\n        this.__isInvalid = true;\n        super._invalidateProperties();\n      }\n\n      /**\n       * Return a template result to render using lit-html.\n       */\n      render(self) {\n        return html$1``;\n      }\n\n      /**\n       * Helper method to re-render the whole setup.\n       */\n      invalidate() {\n        this._invalidateProperties();\n      }\n    }\n\n    return ElementLite;\n  });\n\n  exports.html = html$1;\n  exports.ElementLiteBase = ElementLiteBase;\n  exports.ElementLiteStaticShadow = ElementLiteStaticShadow;\n  exports.ElementLiteLitOnly = ElementLiteLitOnly;\n  exports.ElementLite = ElementLite;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n\n//# sourceURL=webpack:///./node_modules/@littleq/element-lite/dist/element-lite.umd.js?");

/***/ }),

/***/ "./node_modules/@littleq/element-lite/lib/lit-html/lib/repeat.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@littleq/element-lite/lib/lit-html/lib/repeat.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.repeat = repeat;\n\nvar _litHtml = __webpack_require__(/*! ../lit-html.js */ \"./node_modules/@littleq/element-lite/lib/lit-html/lit-html.js\");\n\nconst keyMapCache = new WeakMap(); /**\n                                    * @license\n                                    * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n                                    * This code may only be used under the BSD style license found at\n                                    * http://polymer.github.io/LICENSE.txt\n                                    * The complete set of authors may be found at\n                                    * http://polymer.github.io/AUTHORS.txt\n                                    * The complete set of contributors may be found at\n                                    * http://polymer.github.io/CONTRIBUTORS.txt\n                                    * Code distributed by Google as part of the polymer project is also\n                                    * subject to an additional IP rights grant found at\n                                    * http://polymer.github.io/PATENTS.txt\n                                    */\n\nfunction cleanMap(part, key, map) {\n    if (!part.startNode.parentNode) {\n        map.delete(key);\n    }\n}\nfunction repeat(items, keyFnOrTemplate, template) {\n    let keyFn;\n    if (arguments.length === 2) {\n        template = keyFnOrTemplate;\n    } else if (arguments.length === 3) {\n        keyFn = keyFnOrTemplate;\n    }\n    return (0, _litHtml.directive)(part => {\n        if (!(part instanceof _litHtml.NodePart)) {\n            throw new Error('repeat can only be used on NodeParts');\n        }\n        let keyMap = keyMapCache.get(part);\n        if (keyMap === undefined) {\n            keyMap = new Map();\n            keyMapCache.set(part, keyMap);\n        }\n        const container = part.startNode.parentNode;\n        let index = -1;\n        let currentMarker = part.startNode.nextSibling;\n        for (const item of items) {\n            let result;\n            let key;\n            try {\n                ++index;\n                result = template(item, index);\n                key = keyFn ? keyFn(item) : index;\n            } catch (e) {\n                console.error(e);\n                continue;\n            }\n            // Try to reuse a part\n            let itemPart = keyMap.get(key);\n            if (itemPart === undefined) {\n                const marker = document.createTextNode('');\n                const endNode = document.createTextNode('');\n                container.insertBefore(marker, currentMarker);\n                container.insertBefore(endNode, currentMarker);\n                itemPart = new _litHtml.NodePart(part.instance, marker, endNode);\n                if (key !== undefined) {\n                    keyMap.set(key, itemPart);\n                }\n            } else if (currentMarker !== itemPart.startNode) {\n                // Existing part in the wrong position\n                const end = itemPart.endNode.nextSibling;\n                if (currentMarker !== end) {\n                    (0, _litHtml.reparentNodes)(container, itemPart.startNode, end, currentMarker);\n                }\n            } else {\n                // else part is in the correct position already\n                currentMarker = itemPart.endNode.nextSibling;\n            }\n            itemPart.setValue(result);\n        }\n        // Cleanup\n        if (currentMarker !== part.endNode) {\n            (0, _litHtml.removeNodes)(container, currentMarker, part.endNode);\n            keyMap.forEach(cleanMap);\n        }\n    });\n}\n//# sourceMappingURL=repeat.js.map\n\n//# sourceURL=webpack:///./node_modules/@littleq/element-lite/lib/lit-html/lib/repeat.js?");

/***/ }),

/***/ "./node_modules/@littleq/element-lite/lib/lit-html/lit-html.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@littleq/element-lite/lib/lit-html/lit-html.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.defaultTemplateFactory = defaultTemplateFactory;\nexports.render = render;\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templateCaches = exports.templateCaches = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nconst html = exports.html = (strings, ...values) => new TemplateResult(strings, values, 'html');\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nconst svg = exports.svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg');\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nclass TemplateResult {\n    constructor(strings, values, type, partCallback = defaultPartCallback) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.partCallback = partCallback;\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isTextBinding = true;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            html += s;\n            // We're in a text position if the previous string closed its tags.\n            // If it doesn't have any tags, then we use the previous text position\n            // state.\n            const closing = findTagClose(s);\n            isTextBinding = closing > -1 ? closing < s.length : isTextBinding;\n            html += isTextBinding ? nodeMarker : marker;\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\nexports.TemplateResult = TemplateResult; /**\n                                          * A TemplateResult for SVG fragments.\n                                          *\n                                          * This class wraps HTMl in an <svg> tag in order to parse its contents in the\n                                          * SVG namespace, then modifies the template to remove the <svg> tag so that\n                                          * clones only container the original fragment.\n                                          */\n\nclass SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\nexports.SVGTemplateResult = SVGTemplateResult; /**\n                                                * The default TemplateFactory which caches Templates keyed on\n                                                * result.type and result.strings.\n                                                */\n\nfunction defaultTemplateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        template = new Template(result, result.getTemplateElement());\n        templateCache.set(result.strings, template);\n    }\n    return template;\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param templateFactory a function to create a Template or retreive one from\n *     cache.\n */\nfunction render(result, container, templateFactory = defaultTemplateFactory) {\n    const template = templateFactory(result);\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === template && instance._partCallback === result.partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(template, result.partCallback, templateFactory);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    removeNodes(container, container.firstChild);\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-posisitions, not attribute positions,\n * in template.\n */\nconst nodeMarker = `<!--${marker}-->`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex = /[ \\x09\\x0a\\x0c\\x0d]([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)[ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*)$/;\n/**\n * Finds the closing index of the last closed HTML tag.\n * This has 3 possible return values:\n *   - `-1`, meaning there is no tag in str.\n *   - `string.length`, meaning the last opened tag is unclosed.\n *   - Some positive number < str.length, meaning the index of the closing '>'.\n */\nfunction findTagClose(str) {\n    const close = str.lastIndexOf('>');\n    const open = str.indexOf('<', close + 1);\n    return open > -1 ? str.length : close;\n}\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nclass TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexports.TemplatePart = TemplatePart; /**\n                                      * An updateable Template that tracks the location of dynamic parts.\n                                      */\n\nclass Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const content = this.element.content;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                                                              NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                    if (!node.hasAttributes()) {\n                        continue;\n                    }\n                    const attributes = node.attributes;\n                    // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order. In\n                    // particular, Edge/IE can return them out of order, so we cannot assume\n                    // a correspondance between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < attributes.length; i++) {\n                        if (attributes[i].value.indexOf(marker) >= 0) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute attribute\n                        const stringForPart = result.strings[partIndex];\n                        // Find the attribute name\n                        const attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1];\n                        // Find the corresponding attribute\n                        const attribute = attributes.getNamedItem(attributeNameInPart);\n                        const stringsForAttributeValue = attribute.value.split(markerRegex);\n                        this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));\n                        node.removeAttribute(attribute.name);\n                        partIndex += stringsForAttributeValue.length - 1;\n                    }\n                } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                    const nodeValue = node.nodeValue;\n                    if (nodeValue.indexOf(marker) < 0) {\n                        continue;\n                    }\n                    const parent = node.parentNode;\n                    const strings = nodeValue.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // We keep this current node, but reset its content to the last\n                    // literal part. We insert new literal nodes before this so that the\n                    // tree walker keeps its position correctly.\n                    node.textContent = strings[lastIndex];\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore(document.createTextNode(strings[i]), node);\n                        this.parts.push(new TemplatePart('node', index++));\n                    }\n                } else if (node.nodeType === 8 /* Node.COMMENT_NODE */ && node.nodeValue === marker) {\n                const parent = node.parentNode;\n                // Add a new marker node to be the startNode of the Part if any of the\n                // following are true:\n                //  * We don't have a previousSibling\n                //  * previousSibling is being removed (thus it's not the\n                //    `previousNode`)\n                //  * previousSibling is not a Text node\n                //\n                // TODO(justinfagnani): We should be able to use the previousNode here\n                // as the marker node and reduce the number of extra nodes we add to a\n                // template. See https://github.com/PolymerLabs/lit-html/issues/147\n                const previousSibling = node.previousSibling;\n                if (previousSibling === null || previousSibling !== previousNode || previousSibling.nodeType !== Node.TEXT_NODE) {\n                    parent.insertBefore(document.createTextNode(''), node);\n                } else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a nextSibling add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a new marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(document.createTextNode(''), node);\n                } else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nexports.Template = Template; /**\n                              * Returns a value ready to be inserted into a Part from a user-provided value.\n                              *\n                              * If the user value is a directive, this invokes the directive with the given\n                              * part. If the value is null, it's converted to undefined to work better\n                              * with certain DOM APIs, like textContent.\n                              */\n\nconst getValue = exports.getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (isDirective(value)) {\n        value = value(part);\n        return directiveValue;\n    }\n    return value === null ? undefined : value;\n};\nconst directive = exports.directive = f => {\n    f.__litDirective = true;\n    return f;\n};\nconst isDirective = o => typeof o === 'function' && o.__litDirective === true;\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nconst directiveValue = exports.directiveValue = {};\nconst isPrimitiveValue = value => value === null || !(typeof value === 'object' || typeof value === 'function');\nclass AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n        this._previousValues = [];\n    }\n    _interpolate(values, startIndex) {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const v = getValue(this, values[startIndex + i]);\n            if (v && v !== directiveValue && (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                for (const t of v) {\n                    // TODO: we need to recursively call getValue into iterables...\n                    text += t;\n                }\n            } else {\n                text += v;\n            }\n        }\n        return text + strings[l];\n    }\n    _equalToPreviousValues(values, startIndex) {\n        for (let i = startIndex; i < startIndex + this.size; i++) {\n            if (this._previousValues[i] !== values[i] || !isPrimitiveValue(values[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    setValue(values, startIndex) {\n        if (this._equalToPreviousValues(values, startIndex)) {\n            return;\n        }\n        const s = this.strings;\n        let value;\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n            if (Array.isArray(value)) {\n                value = value.join('');\n            }\n        } else {\n            value = this._interpolate(values, startIndex);\n        }\n        if (value !== directiveValue) {\n            this.element.setAttribute(this.name, value);\n        }\n        this._previousValues = values;\n    }\n}\nexports.AttributePart = AttributePart;\nclass NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === directiveValue) {\n            return;\n        }\n        if (isPrimitiveValue(value)) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        } else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        } else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        } else if (value instanceof Node) {\n            this._setNode(value);\n        } else if (value.then !== undefined) {\n            this._setPromise(value);\n        } else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        if (this._previousValue === value) {\n            return;\n        }\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        value = value === undefined ? '' : value;\n        if (node === this.endNode.previousSibling && node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        } else {\n            this._setNode(document.createTextNode(value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        const template = this.instance._getTemplate(value);\n        let instance;\n        if (this._previousValue && this._previousValue.template === template) {\n            instance = this._previousValue;\n        } else {\n            instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        } else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        this._previousValue = value;\n        value.then(v => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\nexports.NodePart = NodePart;\nconst defaultPartCallback = exports.defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    } else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nclass TemplateInstance {\n    constructor(template, partCallback, getTemplate) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n        this._getTemplate = getTemplate;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            } else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        const fragment = document.importNode(this.template.element.content, true);\n        const parts = this.template.parts;\n        if (parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                                                                   NodeFilter.SHOW_TEXT */, null, false);\n            let index = -1;\n            for (let i = 0; i < parts.length; i++) {\n                const part = parts[i];\n                while (index < part.index) {\n                    index++;\n                    walker.nextNode();\n                }\n                this._parts.push(this._partCallback(this, part, walker.currentNode));\n            }\n        }\n        return fragment;\n    }\n}\nexports.TemplateInstance = TemplateInstance; /**\n                                              * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n                                              * (exclusive), into another container (could be the same container), before\n                                              * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n                                              * container.\n                                              */\n\nconst reparentNodes = exports.reparentNodes = (container, start, end = null, before = null) => {\n    let node = start;\n    while (node !== end) {\n        const n = node.nextSibling;\n        container.insertBefore(node, before);\n        node = n;\n    }\n};\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nconst removeNodes = exports.removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n        const n = node.nextSibling;\n        container.removeChild(node);\n        node = n;\n    }\n};\n//# sourceMappingURL=lit-html.js.map\n\n//# sourceURL=webpack:///./node_modules/@littleq/element-lite/lib/lit-html/lit-html.js?");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ })

}]);